# 입력
## scanf
### 정수
- int %d
- long %ld
- long long %lld
### 실수
- float %f
- double %lf
### 문자 ' '
- char %c
### 문자열 " "
- char %s
## gets

## fgets


# 문자열
## 문자와 비교
문자는 한단어 이고, 끝에 \0 즉 널문자가 없다.  
그러나 문자열은 항상 \0이 마지막에 있어야 된다.
### 변경
하나씩 변경은 불가능하지만 통째로 넣을 순 있다?  
포인터를 사용한 문자열은 상수 영역으로 가기 때문에 변경이 불가능 하다?
- with copilot
> 네, 맞습니다. 포인터 변수로 표현하는 문자열을 문자열 상수라고 합니다. 이 문자열 상수는 변경이 불가능하며, 읽기만 가능합니다. 이는 문자열 상수가 텍스트 세그먼트 영역(읽기 전용)에 저장되기 때문입니다. 따라서, 문자열 상수의 변경 방법은 새로 만드는 방법밖에 없습니다.   
그러나 포인터 변수의 주소 값 자체는 변경이 가능합니다. 즉, 포인터 변수가 가리키는 대상을 다른 문자열 상수로 변경할 수 있습니다. 하지만 그 대상 자체(문자열 상수)를 변경하는 것은 불가능합니다.
## 입력
### scanf("%s",a);
띄어쓰기 직전까지 입력을 받는다.
### gets(a);
엔터 직전까지 입력을 받는다. 엔터는 무시하고 '\0'으로 변환 
#### gets_s
15년부터 바뀌었으나 우리 체점 시스템은 아직 gets를 사용한다.
### fgets(a,크기,stdin);
## 출력
### puts(a);
문자열 출력 후 '\n'까지 해줘서 줄바꿈이 된다.  
### return 
- 성공하면 음수가 아닌 값
- 실패시 EOF(파일의 끝을 나타내는 상수 -1)

## 함수
### strcmp(a,b)
b가 0순위 기준으로 a가 어느 순위 인지 말해줌
### strcpy(a,b)
a에 b를 그대로 복사하여 넣음
### strlen(a)
a의 길이
### strcat(a,b)
a뒤에 b를 붙여줌
### 문자열 숫자 형 변환
- atoi(a): int
- atol(a): long
- atof(a): double

# 포인터
## 메모리
필요한 정보(값)을 저장하는 공간  
1 byte(8bits) 단위로 물리 주소가 부여 되어 있다.
## 주소연산자 &
변수에 할당된 메모리 공간의 시작 주소를 구해준다
## l-value
할당된 공간  
대입문에서 왼쪽 변수
## r-value
저장된 값  
대입문에서 오른쪽 변수, 조건식, 함수의 인자로 사용될 때
## 포인터(자료형)
주소를 나타내는 특수 자료형  
변수 명 앞에 * (참조연산자)만 덧붙이면 된다
- int num,*a=NULL ; char *c=NULL 오류 방지를 위해 NULL로 초기화해주자
- a= &num 으로 이어줄 수 있고 *a로 num의 값을 읽을 수 있다.
### 다중 포인터
in a , *p = &a , **q = p ; ***r = q, ****..... 
## 배열
int num[5];    
num은 배열의 시작 주소 = num[0]의 주소  
num[1] 은 저장된 값  
&num[1] 은 주소
- for(int * p = num; p < num+5 ; p++) 이렇게 활용이 가능하다.
- *p++ 이렇게 값을 수정하려면 *으로 참조 연산자를 사용해야된다.
## 함수
함수에서는 보내준 변수의 주소를 가지고 오는 것이 아닌 값만 가지고 와서 새로 공간을 만든 뒤 끝나면 그 공간을 없앤다.   
즉 그냥 값을 보내면 안되고 주소를 보내야 된다. 또한 함수 안에서도 참조 연산자를 사용하여 값을 다뤄야 한다.
> int main(){  
    int a=3,b[5];  
    func(&a);  
}  
void func(int *a){  
    *a = *a + 3;  
}  

# 구조체
## struct
자료형을 정의하는 것
### 멤버
구조체를 구성하는 변수  
변수.멤버 로 사용 가능
### 선언
struct 구조체이름 변수이름 = { , , , };

## typedef
자료형의 이름을 새로 정의 가능
> typedef int INT;   
typedef int* INTPTR;  
INT num; 
### 구조체에서의 사용
> typedef struct (구조체 이름은 생략 가능) {   
} student(이게 사용할 이름);
## 포인터
### 멤버 접근
(*pst).id = pst->id
## 중첩 구조체
구조체 안에 다른 구조체가 있을 수 있다. 
### 멤버 접근
st.addr.city

# 동적할당
## 정적 할당의 문제
- 필요한 메모리 크기를 알 수 없는 경우, 충분히 큰 크기를 가정해서 선언해야함  
메모리를 효율적으로 사용할 수 없다.
## 할당
malloc(할당할 메모리 크기)
- p= (자료형 *)malloc(size(자료형))
### 실패
if (p==NULL) return -1;
## 해제
free(p)
## calloc
calloc(개수, 자료형)
## 재할당
p= (자료형 *)relloc (p,크기)
